# 入门模拟



模拟题是一类 “ 题目怎么说，你就怎么做 ” 的题目，这类题目不涉及算法，完全只是根据题目的描述来进行代码的编写，考察的是代码能力。



## 一、乙级题目：

### 1、程序运行时间：

不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。

**（1）输入格式：**输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 < C2，并且取值在 [0,107]。

**（2）输出格式：**在一行中输出被测函数运行的时间。运行时间必须按照 `hh:mm:ss`（即2位的 `时:分:秒`）格式输出；不足 1 秒的时间四舍五入到秒。

```C++
#include <iostream>
#include <cmath>
#define CLK_TCK 100
using namespace std;

int main(){
    int time, h, m,s;
    double c1, c2, seconds;
    scanf("%lf%lf", &c1, &c2);
    seconds = round( (c2 - c1)/CLK_TCK );
    time = (int) seconds;
    h = time/3600;                       	// 计算经过了多少个小时
    m = (time - 3600*h)/60;
    s = time - 3600*h - 60*m;
    printf("%02d:%02d:%02d\n", h, m, s);
    return 0;
}
```

### 2、数字分类：

（1）给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：

- *A*1 = 能被 5 整除的数字中所有偶数的和；
- *A*2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 *n*1−*n*2+*n*3−*n*4⋯；
- *A*3 = 被 5 除后余 2 的数字的个数；
- *A*4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；
- *A*5 = 被 5 除后余 4 的数字中最大数字。

（2）输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N*，随后给出 *N* 个不超过 1000 的待分类的正整数。数字间以空格分隔。

（3）输出格式：对给定的 *N* 个正整数，按题目要求计算 *A*1~*A*5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若分类之后某一类不存在数字，则在相应位置输出 `N`。

```C++
#include <iostream>
using namespace std;
int main(){
    int n;
    int a[5] = {0}, count[5] = {0};
    scanf("%d", &n);
    int array[n];
    for(int i=0;i<n;i++){
        scanf("%d", &array[i]);
        if(array[i] % 5 == 0){                    //被5整除的偶数之和
            if(array[i] % 2 ==0){
                a[0] += array[i]; 
                count[0]++;
            } 
        }
        else if(array[i] % 5 == 1){               //除5余1的数的交错求和
            if(count[1] % 2 == 0) a[1] += array[i];
            else a[1] -= array[i];
            count[1]++;
        }
        else if(array[i] % 5 == 2){               //除5余2的数字个数
            count[2]++;
        }
        else if(array[i] % 5 == 3){               //除5余3的数字的平均数
            a[3] += array[i];
            count[3]++;
        }
        else if(array[i] % 5 == 4){               //除5余4的数字中的最大值
            if(a[4] < array[i]){
                a[4] = array[i]; 
                count[4]++;
            } 
        }
    }
    
    if(count[0] == 0) printf("N ");
    else printf("%d ",a[0]);
    if(count[1] == 0) printf("N ");
    else printf("%d ",a[1]);
    if(count[2] == 0) printf("N ");
    else printf("%d ",count[2]);
    if(count[3] == 0) printf("N ");
    else printf("%.1f ", (double)a[3]/count[3]);
    if(count[4] == 0) printf("N");
    else printf("%d",a[4]);
    return 0;
}
```

### 3、锤子、剪刀、布：

（1）输入格式：输入第 1 行给出正整数 *N*（≤105），即双方交锋的次数。随后 *N* 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。`C` 代表“锤子”、`J` 代表“剪刀”、`B` 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。

（2）输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。

```c++
#include <iostream>
using namespace std;
int main(){
    int n, jid=0, yid=0;
    int jia_sheng=0, jia_ping=0, jia_fu=0;       // 记录甲胜、平、负的次数
    int yi_sheng=0, yi_ping=0, yi_fu=0;          // 记录乙胜、平、负的次数
    int jia[3]={0}, yi[3]={0};                   // 按照BCJ的顺序记录甲乙所用手势的次数
    char fiture[2], konge;
    
    scanf("%d", &n);
    for(int i=0;i<n;i++){
        getchar();
        scanf("%c %c", &fiture[0], &fiture[1]);
        // printf("%c %c\n", fiture[0], fiture[1]);
        // 甲赢
        if((fiture[0] == 'C' && fiture[1] == 'J') || (fiture[0] == 'J' && fiture[1] == 'B') || (fiture[0] == 'B' && fiture[1] == 'C')){
            jia_sheng++;yi_fu++;
            if(fiture[0] == 'B') jia[0]++;
            else if(fiture[0] == 'C') jia[1]++;
            else if(fiture[0] == 'J') jia[2]++;
        }
        // 乙赢
        else if((fiture[0] == 'J' && fiture[1] == 'C') || (fiture[0] == 'B' && fiture[1] == 'J') || (fiture[0] == 'C' && fiture[1] == 'B')){
            jia_fu++;yi_sheng++;
            if(fiture[1] == 'B') yi[0]++;
            else if(fiture[1] == 'C') yi[1]++;
            else if(fiture[1] == 'J') yi[2]++;
        }
        // 平局
        else{
            jia_ping++;yi_ping++;
        }
    }
    printf("%d %d %d\n", jia_sheng, jia_ping, jia_fu);
    printf("%d %d %d\n", yi_sheng, yi_ping, yi_fu);
    
    for(int i=1;i<3;i++){
        if(jia[jid] < jia[i]) jid = i;
        if(yi[yid] < yi[i]) yid = i;
    }
    if(jid == 0) printf("B ");
    else if(jid == 1) printf("C ");
    else if(jid == 2) printf("J ");

    if(yid == 0) printf("B");
    else if(yid == 1) printf("C");
    else if(yid == 2) printf("J");
    
    return 0;
}
```

### 4、一元多项式求导：

设计函数求一元多项式的导数。（注：*x**n*（*n*为整数）的一阶导数为*n**x**n*−1。）

**（1）输入格式：**以**指数递降**方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。

**（2）输出格式：**以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。

注意“零多项式”的指数和系数都是 0，但是表示为 `0 0`。

```C++
#include <iostream>
using namespace std;
int main(){
    int a[1010] = {0};
    int xishu, zhishu, count=0;    //count记录不为0导数项的个数
    while(scanf("%d %d", &xishu, &zhishu) != EOF){
        a[zhishu] = xishu;
    }
    a[0] = 0;                     //零次项求导后为0
    for(int i=1;i<=1000;i++){
        a[i-1] = a[i] * i;        //求导公式
        a[i] = 0;                 //此句不可省略
        if(a[i-1] != 0) count++;
    }
    if(count == 0) printf("0 0"); //特判
    else{
        for(int i=1000;i>=0;i--){
            if(a[i] != 0){
                printf("%d %d", a[i], i);
                count--;
                if(count != 0) printf(" ");
            }
        }
    }
    return 0;
}
```
